# ========================================================
# PLAY 1: Infrastructure - Deploy K8s (Run:ai Ready)
# ä¿®æ­£ç‰ˆ: å°‡ Ingress/MetalLB æ”¹ç‚º Post-Install æ­¥é©Ÿ
# ========================================================
- name: 1. Infrastructure - Deploy Modern Charmed Kubernetes
  hosts: maasjuju
  gather_facts: yes
  vars:
    test_model: "k8s-cluster-runai"
    k8s_channel: "1.31/stable"
    bundle_path: "{{ ansible_user_dir }}/charmed-k8s-core.yaml"
    
    # MetalLB IP è¨­å®š (è«‹ç¢ºèªé€™æ˜¯ä½  VM ç¶²æ®µçš„é–’ç½® IP)
    metallb_ip_range: "192.168.1.200-192.168.1.210"

  tasks:
    # --- 1. Cleanup & Model ---
    - name: 1.0 Force cleanup old model
      command: "juju destroy-model {{ test_model }} --no-prompt --force --destroy-storage"
      register: destroy_result
      failed_when: destroy_result.rc != 0 and '"not found" not in destroy_result.stderr'
      ignore_errors: yes

    - name: 1.1 Wait for model release
      pause: seconds: 15

    - name: 1.2 Create new Juju Model
      shell: juju add-model {{ test_model }}

    # --- 2. Core Bundle (åªåŒ…å«åŸºç¤å»ºè¨­) ---
    - name: 2.1 Generate Core Bundle
      copy:
        dest: "{{ bundle_path }}"
        mode: '0644'
        content: |
          description: Core K8s Cluster
          base: ubuntu@22.04
          machines:
            "0": {constraints: tags=runai}
            "1": {constraints: tags=runai}
            "2": {constraints: tags=runai}
          applications:
            easyrsa: {charm: easyrsa, channel: latest/stable, num_units: 1, to: ["0"]}
            etcd: {charm: etcd, channel: latest/stable, num_units: 1, to: ["0"]}
            kubernetes-control-plane: 
              charm: kubernetes-control-plane
              channel: {{ k8s_channel }}
              num_units: 1
              to: ["0"]
              options: {allow-privileged: "true"}
            kubernetes-worker:
              charm: kubernetes-worker
              channel: {{ k8s_channel }}
              num_units: 2
              to: ["1", "2"]
              expose: true
            calico: {charm: calico, channel: latest/stable}
            containerd: {charm: containerd, channel: latest/stable}
          relations:
            - ["kubernetes-control-plane:kube-control", "kubernetes-worker:kube-control"]
            - ["kubernetes-control-plane:certificates", "easyrsa:client"]
            - ["etcd:certificates", "easyrsa:client"]
            - ["kubernetes-control-plane:etcd", "etcd:db"]
            - ["kubernetes-worker:certificates", "easyrsa:client"]
            - ["calico:etcd", "etcd:db"]
            - ["calico:cni", "kubernetes-control-plane:cni"]
            - ["calico:cni", "kubernetes-worker:cni"]
            - ["containerd:containerd", "kubernetes-worker:container-runtime"]
            - ["containerd:containerd", "kubernetes-control-plane:container-runtime"]

    - name: 2.2 Deploy Bundle
      shell: juju deploy {{ bundle_path }} --model {{ test_model }} --trust
      register: deploy_out
      until: deploy_out.rc == 0
      retries: 3
      delay: 10

    # --- 3. Wait for K8s Ready ---
    - name: 3.1 Wait for Juju Apps Active
      shell: |
        echo "â³ Monitoring Juju status (Timeout: 45min)..."
        for i in {1..540}; do
          JSON=$(juju status --model {{ test_model }} --format json)
          CP=$(echo "$JSON" | jq -r '.applications["kubernetes-control-plane"]["application-status"].current // "unknown"')
          WK=$(echo "$JSON" | jq -r '.applications["kubernetes-worker"]["application-status"].current // "unknown"')
          if [[ "$CP" == "active" && "$WK" == "active" ]]; then
            echo "âœ… Core Juju Apps are Active!"
            exit 0
          fi
          if (( i % 12 == 0 )); then echo "   [$i/540] Waiting... (CP=$CP, WK=$WK)"; fi
          sleep 5
        done
        exit 1
      args: {executable: /bin/bash}
      register: juju_wait
      changed_when: false

    # --- 4. Post-Install: Storage & Metrics ---
    - name: 4.1 Install Local Path Provisioner
      shell: |
        juju ssh --model {{ test_model }} 0 -- \
        "kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.30/deploy/local-path-storage.yaml"

    - name: 4.2 Set Default StorageClass
      shell: |
        juju ssh --model {{ test_model }} 0 -- \
        "kubectl patch storageclass local-path -p '{\"metadata\": {\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"}}}'"

    - name: 4.3 Install Metrics Server (Required for Run:ai)
      shell: |
        juju ssh --model {{ test_model }} 0 -- \
        "kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml"
        # Patch allow-insecure for self-signed certs in lab
        juju ssh --model {{ test_model }} 0 -- \
        "kubectl patch deployment metrics-server -n kube-system --type='json' -p='[{\"op\": \"add\", \"path\": \"/spec/template/spec/containers/0/args/-\", \"value\": \"--kubelet-insecure-tls\"}]'"

    # --- 5. Post-Install: MetalLB (Load Balancer) ---
    - name: 5.1 Install MetalLB
      shell: |
        juju ssh --model {{ test_model }} 0 -- bash -s <<'EOS'
        kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.12/config/manifests/metallb-native.yaml
        echo "â³ Waiting for MetalLB Controller..."
        kubectl wait --namespace metallb-system --for=condition=ready pod --selector=app=metallb --timeout=300s
        EOS

    - name: 5.2 Configure MetalLB Pool
      shell: |
        juju ssh --model {{ test_model }} 0 -- bash -s <<'EOS'
        cat <<EOF | kubectl apply -f -
        apiVersion: metallb.io/v1beta1
        kind: IPAddressPool
        metadata:
          name: first-pool
          namespace: metallb-system
        spec:
          addresses:
          - {{ metallb_ip_range }}
        ---
        apiVersion: metallb.io/v1beta1
        kind: L2Advertisement
        metadata:
          name: l2-advert
          namespace: metallb-system
        EOF
        EOS

    # --- 6. Post-Install: Ingress NGINX ---
    - name: 6.1 Install NGINX Ingress Controller
      shell: |
        juju ssh --model {{ test_model }} 0 -- bash -s <<'EOS'
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.0/deploy/static/provider/cloud/deploy.yaml
        echo "â³ Waiting for Ingress Controller..."
        # ç­‰å¾… Deployment å»ºç«‹
        sleep 10
        kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=300s
        EOS

    # --- 7. Post-Install: TLS Secret ---
    - name: 7.1 Generate TLS Secret for Run:ai
      shell: |
        juju ssh --model {{ test_model }} 0 -- bash -s <<'EOS'
        set -e
        kubectl create namespace runai-backend --dry-run=client -o yaml | kubectl apply -f -
        
        openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes \
          -keyout private.pem -out fullchain.pem \
          -subj "/CN=runai.lab.local"
        
        if ! kubectl get secret runai-backend-tls -n runai-backend; then
            kubectl create secret tls runai-backend-tls -n runai-backend \
              --cert=fullchain.pem \
              --key=private.pem
            echo "âœ… Created TLS Secret: runai-backend-tls"
        fi
        rm -f private.pem fullchain.pem
        EOS

    # --- 8. Final Check ---
    - name: 8.1 Check Ingress IP
      shell: |
        juju ssh --model {{ test_model }} 0 -- bash -s <<'EOS'
        echo "Waiting for LoadBalancer IP..."
        sleep 15
        LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "---------------------------------------------------------"
        echo "âœ… Cluster Ready!"
        echo "ğŸ”‘ Ingress IP: $LB_IP"
        echo "ğŸ“ ACTION: Add '$LB_IP runai.lab.local' to /etc/hosts"
        echo "---------------------------------------------------------"
        EOS
      changed_when: false
